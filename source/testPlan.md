This file is a thorough description of all functional testing conducted on the calculator. Each of the mentioned functionalities were thoroughly tested in addition to the basic functionalities expected from a calculator. Edge cases were used in all situations, as were normal use cases. Edge cases generally involved negative numbers, extreme numbers such as infinity or NaN.

Buttons:
All buttons were tested by both clicking and typing since both options are avaialable to the user. This also included pressing/typing buttons that appeared to be greyed out and ensuring that values would not be entered when these buttons are unavailable. All number buttons and basic operations were tested to correctly appear in the display at the top of the calculator when the corresponding button was pressed or the key typed. As expected, if a greyed out button is typed or pressed, its value will not appear in the display.

Memory:
The memory functions were tested by saving a value to memory and then ensuring that it could be called again. This also included ensuring that the memory value was treated as an atomic value and can't simply be tacked onto the end of an existing value. In other words, if the screen shows 3 and the memory value is 5, calling the memory should not give 35 because a situation in which a user would want this is not very likely. The M+ was also tested by saving a value to memory and ensuring that the onscreen value was correctly added to memory when called.

Modes (Binary/Hexadecimal/Decimal):
Each mode was tested in a similar manner. First, it was ensured that all invalid values were greyed out when switching modes. For example, numbers above 1 are not allowed in binary mode while letters are not allowed in binary and decimal but they are allowed in hexadecimal. Secondly, it was ensured that each of the operations worked as expected for each of the modes. It was checked that the memory, display and history all clear when switching between modes in order to ensure that invalid symbols cannot be used in different modes.

Operations:
Each of the operations was thoroughly tested by using various values. It was also ensured that the provided operation would evaluate if a second operation was requested. In other words, if the user has already typed 3+5 and then decides to type *2, the first part of the operation will be evaluated to 8 and the screen will show 8* and the user can proceed to type the second argument for the next operation. The results of each of the operations was also ensured to be consistent with what is expected by testing the same operations by hand on an existing calculator. It was also tested that after typing an operation, the user cannot input another operation without first providing a numerical argument. This ensures that they will not input something such as 5++5, which is obviously meaningless.

Continuity:
A portion of the testing involved continuity testing that ensured that the calculator would act as expected under extended use. For example, it was tested that numbers cannot be tacked onto the end of a result. It seems unlikely that the user would want to do 3+5 and get 8 and then turn that 8 into 85 by just typing a 5. Instead, typing a number after getting a result clears the screen and starts a new number. The same occurs for the result of operations that do not require the equals key to be pressed, such as trig functions and sqrt. Additionally, it was ensured that the screen would clear when switching between modes (binary/hexadecimal/decimal). This guarantees that the user will not have an invalid number (such as a 5 when switching to binary) present on the display. Additionally, it was tested that if the user tries to string together multiple operations, each one would be evaluated and the result displayed before allowing the user to input the next argument. This was to ensure that the user did not receive unexpected results due to the lack of availability of parentheses. 

Edge Values:
The calculator was tested for various edge values. These are INFINITY, -INFINITY and NaN. Both infinities are treated in the same manner JavaScript treats overflow numbers and it is ensured that the user will not conduct operations on infinity. NaN is displayed if the user attempts an invalid operation, such as 5+ followed by equals. The user cannot conduct operations on NaN and any new input will clear the display and begin with a clean display.

History:
The history functionality was tested by making normal use of the calculator and ensuring that various types of expressions were saved to history. These expressions were then recalled in order to make sure that they were properly displayed on the screen upon recall and that the ensuing operations could deal with the recalled expressions appropriately. For example, even though the history shows sqrt(#), sqrt in the display would result in NaN so it is evaluated when it is called back to history. It was also checked that the history clears correctly when switching between modes.